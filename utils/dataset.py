import os
import json
import numpy as np
import cv2
import pathlib


class HabitatDataset:
    '''Loads data generated by the datagen_habitat code.'''
    def __init__(self, data_dir):
        '''
        Instantiate a dataset loader for the habitat generated data. If loading
        a data folder with many different scenes, the metadata pertaining to camera
        intrinsics and other non-episode specific data is taken from the first
        metadata file found in the folder.
        Args:
            meta_file (str): path to the metadata file or folder containing meta files. 
                in it or in its subfolders.'''
        if data_dir[-5:] == '.json':
            self._data_dir = os.path.dirname(data_dir)
            fdir = open(data_dir, 'r')
            self._data_dict = json.load(fdir)
        elif pathlib.Path(data_dir).is_dir():
            self._data_dir = ''
            p = pathlib.Path(data_dir)
            meta_dirs = list(p.rglob('*.json'))

            assert len(meta_dirs) > 0, "No json files found in directory"

            # Instantiate data dict
            with open(meta_dirs[0].resolve(), 'r') as fdir: 
                self._data_dict = json.load(fdir)
            self.append_datadir_to_image_paths(self._data_dict, 
                                               meta_dirs[0].resolve().parent)

            # Add data from episodes from other files
            for fdir in meta_dirs[1:]:
                with open(fdir.resolve(), 'r') as file: 
                    next_dict = json.load(file)
                    self.append_datadir_to_image_paths(next_dict,
                                            fdir.resolve().parent)
                    self._data_dict['episodes'].extend(next_dict['episodes'])
        else:
            raise ValueError(f"Invalid data location: {data_dir}")

    def append_datadir_to_image_paths(self, metadata, data_dir):
        for i in range(len(metadata['episodes'])):
            e = metadata['episodes'][i]
            e['color'] = f"{data_dir}/{e['color']}"
            e['depth'] = f"{data_dir}/{e['depth']}"
            e['mask'] = f"{data_dir}/{e['mask']}"
            e['coord'] = f"{data_dir}/{e['coord']}"

    def intrinsic(self):
        return np.array(self._data_dict['meta']['camera_intrinsic'])

    def __len__(self):
        return len(self._data_dict['episodes'])

    def __getitem__(self, i):
        e = self._data_dict['episodes'][i]  # Episode Metadata  
        format = self._data_dict['meta']['img_format']
        rgb_f = f"{self._data_dir}/{e['color']}.{format}"
        d_f = f"{self._data_dir}/{e['depth']}.{format}"
        s_f = f"{self._data_dir}/{e['mask']}.{format}" if 'mask' in e else None
        c_f = f"{self._data_dir}/{e['coord']}.{format}" if 'mask' in e else None

        r = {}  # Results
        if format == 'npy':
            r['image'] = np.load(rgb_f)
            r['depth'] = np.load(d_f)
            r['semantics'] = np.load(s_f) if s_f else None
        else:
            rgb = cv2.imread(rgb_f, cv2.IMREAD_ANYCOLOR) 
            r['image'] = cv2.cvtColor(rgb, cv2.COLOR_BGR2RGB)
            r['depth'] = cv2.imread(d_f, cv2.IMREAD_ANYDEPTH).astype(np.float32) * 10**(-3)
            r['semantics'] = cv2.imread(s_f, cv2.IMREAD_ANYDEPTH).astype(np.uint8)
            r['nocs'] = cv2.imread(c_f, cv2.COLOR_BGR2RGB)

        e['intrinsics'] = self.intrinsic()

        return r, e

    def get_transform(self, i, obj_handle): 
        e = self._data_dict['episodes'][i]
        obj = e['objects'][obj_handle]
        return np.array(obj['transformation'])

    def get_relative_transform(self, source, target, obj_handle=None):
        if obj_handle is None:
            obj_handle = list(self._data_dict['episodes'][source]['objects'].keys())[0]
        T_s = self.get_transform(source, obj_handle)
        T_t = self.get_transform(target, obj_handle)
        return T_t@np.linalg.inv(T_s)
